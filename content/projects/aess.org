#+title: Concequences of Approximations in physics
#+author: vijay panchal
#+date: <2023-04-03 Mon>
#+categories[]: Physics Projects
#+draft: False
#+tags[]: MSc project physics
#+thumbnail: 
#+description: This was my MSc sem 1 project, in which i discussed about problem with aprroximations and it's ignorance in physics. I took one example of simple pendulum and simulated it with python and pygame.
#+tableofcontents: true
#+abstract:true 




{{< abstract >}} Approximation methods is essential topic in physical science but consequences are rarely discussed.  In this project we are trying to discuss one classical example of approximation from early physics stage. This example is so rooted in our mind but still we rarely know bezarre intricancy of it. In example, we gave simple pendulum motion but be carefull it’s not that simple. The nonlinearity come in it is starting of ordered chaos. Even nonlinearity does not stop there, we got nonlinear dampings which have it’s own implications but in this small project we didn’t go in that rabit hole. We present one simulation with two equation of motion and it’s solutions. How this two solution of simple pendulum with two type of damping (linear and quadratic) are behaved is our main interest in this project.{{< /abstract >}}





Physicists love to
do approximations, like in functional expansion for getting polynomials
for their ease or may be specialized idealization in particular topic.
Approximation help them to *seeing through physics* instead of going in
to maze of exactness in formidable mathematics. Getting interpretation
or i say knowing system is sometime more important then going for
regorious mathematics. For example, famous equation of fluid dynamics
*Navier-Stoke equation* can be imposible to solve but as physicist they
know what it is.

Be aware, that approximation is just approximation. We should remember
everytime we do that. Sometime we forgot actual system which is far from
ideal. We should know that we are on mission to know nature not just
building new theories.

Let's dive into one example, that showes implication of approximations.
In classical mechanics, we have some major theories, one is of
oscillatory motions. In Oscillation theory we studied *Simple Harmonic
Oscillation*, but as we are going to see that simple harmonic
oscillation is not exactly that simple without approximation. We had
actually changed whole system unknowingly, but beauty of physics is that
it is still help to understand concept and motion of it.

Before that we would like to show gratitude to literature that helped us
to finish this project. Firstly, for our classical mechanics textbooks
classical mechanics by goldstein @goldstein2002classical and by
J.C. Upadhyay [cite:@upadhyay2016classical]. Then book on differential
equations [cite:@bronson2014schaum] and [cite:@jordan2007nonlinear].
Estimation of parameters of damping forces
[cite:@salamon2020estimation]. Also, some python library i used in this
projects are numpy for calculation [cite:@harris2020array] , matplotlib
[cite:@Hunter2007] for graphs and pygame for simulation
[[https://github.com/pygame/pygame]] .

* Example of Approximation
  :PROPERTIES:
  :CUSTOM_ID: sec:orga9fb35e
  :END:
Approximation is used in almost every branch of physics, not just
physics but every field of sciences. We are going to give profound
example of understanding advantages and disadvantages of approximation.

** Defining our problem
   :PROPERTIES:
   :CUSTOM_ID: sec:org4128a9d
   :END:
We learned simple pendulum from very starting of physics course. But
what if i say that simple pendulum is not actually simple in sense that
approximation hide most of things away from our eyes to see.

Let's take one pendulum,by taking length \(l = 1 m\) string (assuming
non deforming) attaching to bob of mass \(m = 0.1 kg\). String attached
to rigid wall as shown in figure. Then we give it a initial deviation as
\(\theta\) initial \(\theta_{0}\). Initial velocity of system
\(v_{0}=0\). We have accelaration of \(g=9.8\) downward.

#+caption: pendulum with string lenth \(l\) and mass \(m\)
[[../images/figure1.png]]

For understanding consequences of approximation, we took simulations by
solving both equation of motion (approximated and exact). For getting
equations of motion we used *Newtonian formulation* which is quite easy
to work with in this type of problems, since we are working with *non
conservative* system.

** Pendulum motion in presence of damping force
   :PROPERTIES:
   :CUSTOM_ID: sec:orgce24ccf
   :END:
In real situations we have non-conservative forces affecting on system.
In our system we have air resistance acting on bob. This drag force will
always be proportional to it's physical shape and size. Since, we can't
tell exactly drag force mathematically, We have *two often used
approximations*. Firstly, there is stockes's law of drag which is
linearly proportional to the velocity. Then we have Newton's drag law
which is quadratically proportional to the velocity.

We will see that how this two approximation affect our system and it's
simulation. We also see mathematical forms of this two but firstly,
let's define this two damping coefficient.

*** Damping by linear to the velocity approximation
    :PROPERTIES:
    :CUSTOM_ID: sec:org55e0b81
    :END:
Let's discuss coffiecient of linear damping. Linear to the velocity drag
is also called stoke's drag. We can write equation of damping by
\(F_{damping} = k_{l}v\). Where, \(k_{l}\) is damping coefficient, value
of it depend on shape of object. For our spherical bob it has for of
\(k_{l} = 3\pi\eta d\), where \(\eta\) is dynamic viscosity of medium
and have values of \(\eta = \rho \nu\). We have \(d\) as diameter of
sphere, for our purpose we are using as \(d=0.01m\).

*** Damping by quadratic to the velocity approximation
    :PROPERTIES:
    :CUSTOM_ID: sec:org45f4934
    :END:
We used quadratic damping approximation as nonlinear damping
approximation. This is also called newton's drag and it's better
approximation then linear one. As quantitatively it can work with
turbulent flow with 1000 to 100000 reynolds number. Where linear
approximation works reynold's number upto 1. Quadratic damping is better
than linear approximation but we can't have close form solution, it is
the reason we use linear damping approximation. In quadratic damping it
has following form, \(F_{damping} = k_{q} v^{2}\). Here,
\(k_{q} = \frac{1}{8}c_{d}\rho \pi d^{2}\), where \(c_{d}\) is drag
coefficient and has value of 0.47. \(\rho\) and \(d\) are density of
fluid and diameter.[cite:@lubarda2021analysis] [cite:@goossens2019review]

** Equation of motion
   :PROPERTIES:
   :CUSTOM_ID: sec:org6e50c3b
   :END:
Let's derive equation of motion for our system which can be modified as we took approximations in it. We have Figure 1 showing pendulum with unextensible string of length \(l\) with sphere of diameter \(d\) and mass \(m\). Our system is in fluid with density \(\rho\) and viscosity \(\eta\). Let's use newton's law of motion to derive equation of motion,

First of all, we compared horizontal and vertical forces.

\begin{equation}
\label{eq:org8df8e37}
   F_{damping}cos(\theta)-Tsin(\theta)=ma_{x}
\end{equation}
\begin{equation}
\label{eq:orge79fc96}
   F_{damping}sin(\theta)+Tcos(\theta)-mg=ma_{y}
\end{equation}

Adding equation \ref{eq:org8df8e37} and equation \ref{eq:orge79fc96} with multiplication by \(cos(\theta)\) and \(sin(\theta)\) respectively.

\begin{equation*}
\label{eq:org5cc3317}
F_{damping}sin^{2}(\theta)+F_{damping}cos^{2}(\theta)-mgsin(\theta)=ma_{x}cos(\theta)+ma_{y}sin(\theta)
\end{equation*}

\begin{equation*}
\label{eq:org5fcf6b1}
F_{damping}-mgsin(\theta)=m(asin^{2}(\theta)+acos^{2}(\theta))
\end{equation*}

\begin{equation}
\label{eq:orgd2aa0c3}
F_{damping}-mgsin(\theta)=ma
\end{equation}

From,
\begin{equation*}
\label{eq:orgacf3267}
a = (\ddot{r}-r\dot{\theta}^{2})\hat{r} + (r \ddot{\theta}+2\dot{r}\dot{\theta})\hat{\theta}
\end{equation*}

Where,  \(r=l\) and since \(\dot{l}=0\), \(a=l\ddot{\theta}\). So, equation \ref{eq:orgd2aa0c3} becomes,

\begin{equation}
\label{eq:org2f6bde8}
F_{damping}-mgsin(\theta)=ml\ddot{\theta}
\end{equation}

This is *exact equation of motion*. Which will be *second order non linear equation*. Finding it's exact solution is another ordeal. Let's take our approximations and cases for it.

*** Approximation of equation of motion : Linear differential equation with linear damping
    :PROPERTIES:
    :CUSTOM_ID: sec:orgcae63fa
    :END:

In class, we approximated equation \ref{eq:org2f6bde8} as \(\theta \to 0\) as \(sin(\theta) \to \theta\). Consequently, this equation becomes very easy to solve. Also, damping force will be,

\begin{equation*}
\label{eq:org64c41ae}
F_{damping}=-k_{l}v
\end{equation*}

\begin{equation*}
\label{eq:orge333cac}
F_{damping}=-k_{l}l\dot{\theta}
\end{equation*}

So, equation \ref{eq:org2f6bde8} becomes,

\begin{equation}
\label{eq:org3d95b41}
\ddot{\theta}+\frac{k_{l}}{m}\dot{\theta}+\frac{g}{l}\theta=0
\end{equation}

\begin{equation}
\label{eq:org7f057dc}
\ddot{\theta}+\Gamma\dot{\theta}+w_{0}^{2}\theta=0
\end{equation}

Where, we took \(\Gamma = \frac{k_{l}l}{m}\) and \(w_{0}^{2}\).

We can solve this linear equation \ref{eq:org7f057dc} by usual methods of linear differential equation. Simply taking \(\theta=e^{\lambda t}\), which gives polynomials of second order.

\begin{equation}
\label{eq:org0b486b4}
\lambda^{2}+\Gamma\lambda+w_{0}^{2}=0
\end{equation}

We can find roots of this quadratic equation.

\begin{equation}
\label{eq:org37b5073}
\lambda = \frac{-\Gamma}{2} \pm \frac{\sqrt{\Gamma^{2}-4w_{0}^{2}}}{2}
\end{equation}

\begin{equation}
\label{eq:orgf9aa1e8}
\lambda = \frac{-\Gamma}{2} \pm \sqrt{\frac{\Gamma}{2}^{2}-w_{0}^{2}}
\end{equation}

Here we getting three type of roots,

1. Roots where \(\frac{\Gamma}{2}=w\). this is *critical damping
   condition*, where we getting \(\lambda=\frac{-\Gamma}{2}\). Putting
   \(\lambda\) into our solutions, \(\theta = e^{\frac{-\Gamma}{2}t}\).
   Which suggest this will only decay with time and never overshoots
   from equilibrium position. Which is desired in certain condition but
   not for us.

2. Roots where \(\frac{\Gamma}{2}>w\). this is *overdamping condition*,
   where we getting
   \(\lambda=\frac{-\Gamma}{2}\pm\sqrt{\frac{\Gamma}{2}^{2}-w_{0}^{2}}\).
   So from here we get
   \(\theta = e^{\frac{-\Gamma}{2}t}e^{\pm\sqrt{\frac{\Gamma}{2}^{2}-w_{0}^{2}}t}\).
   This also have exponential term in it which will only decay with time
   and never overshoots from equilibrium position.

3. Roots where \(\frac{\Gamma}{2}<w\). this is *underdamping condition*,
   here
   \(\lambda=\frac{-\Gamma}{2}\pm i\sqrt{w_{0}^{2}-\frac{\Gamma}{2}^{2}}\).
   \(\theta = e^{\frac{-\Gamma}{2}t}e^{\pm i \sqrt{w_{0}^{2}-\frac{\Gamma}{2}^{2}}t}\).
   This has complex term, which implicitly suggest that it'll overshoot
   and oscillate. This our topic of interest for this project.


Without forgetting our initial system we came to we took third case as our solution.

\begin{equation*}
\label{eq:org19bc511}
\theta = e^{\frac{-\Gamma}{2}t}e^{\pm i \sqrt{w_{0}^{2}-\frac{\Gamma}{2}^{2}}t}
\end{equation*}

Taking \(w^{2} = w_{0}^{2}-\frac{\Gamma}{2}^{2}\). And writing our solution in linear combination from above equation,

\begin{equation}
\label{eq:org69aca21}
\theta = e^{\frac{-\Gamma}{2}t}(C_{1}e^{iwt}+C_{2}e^{-iwt})
\end{equation}

Taking real part of equation \ref{eq:org69aca21}. Since it'll represent real motion of system. At last we get equation like this,

\begin{equation}
\label{eq:orgfa1e4db}
\theta = e^{\frac{-\Gamma}{2}t}A cos(wt-\delta)
\end{equation}

Where, \(A\) and \(\delta\) can be find from initial conditions and \(w = \sqrt{w_{0}^{2}-\frac{\Gamma}{2}^{2}}\).

*** Non linear equation of motion with linear damping
    :PROPERTIES:
    :CUSTOM_ID: sec:org182b73a
    :END:

In equation \ref{eq:org2f6bde8} we can write linear damping term without taking approximation as \(sin(\theta) \to \theta\),

Writing again \ref{eq:org2f6bde8}, 
\begin{equation*}
\label{eq:org63731a3}
F_{damping}-mgsin(\theta)=ml\ddot{\theta}
\end{equation*}

Here, putting \(F_{damping}=-k_{l}l\dot{\theta}\) will give us,

\begin{equation}
\label{eq:org2506add}
\ddot{\theta}+\frac{k_{l}}{m}\dot{\theta}+\frac{g}{l}sin(\theta)=0
\end{equation}

This is second order nonlinear equation we can't get it's closed form solution but we can get numerical one. Let's make it easy to use in numerical methods.

Take \(\phi = \dot{\theta}\) and \(\frac{k_{l}}{m}=\Gamma\). So, equation \ref{eq:org2506add} becomes,

\begin{equation}
\label{eq:org5c4e7c5}
\dot{\phi}+\Gamma\phi=-\frac{g}{l} sin(\theta)
\end{equation}

We can use numerical methods like Runge-Kutta method to solve this equation. I have given brief overview of runge kutta methods in appendix 1. For that we define \(\phi\) and \(\dot{\phi}\) as following,

\begin{equation}
\label{eq:org05a9f91}
\phi=\dot{\theta}
\end{equation}

\begin{equation}
\label{eq:orge830ec7}
\dot{\phi}=-\Gamma\phi-\frac{g}{l} sin(\theta)
\end{equation}

We have two complementary equations \ref{eq:org05a9f91} and \ref{eq:orge830ec7}. We can use now Runge-Kutta method on it. I have used in my code file /main.py/, you can access it in appendix.

*** Simulations of the two equations
    :PROPERTIES:
    :CUSTOM_ID: sec:org737090b
    :END:
    
I have done nice simulation which give hands on experience of two equation, both have very similar results when \(\theta\) is very small, again understandable as \(\theta \to 0\) we can approximate \(sin(\theta) \to \theta\). But when \(\theta\) increase slightly we have massive changes in solution with time. Let's look at \(\theta = \frac{\pi}{10}\), (here, we take viscosity of air at \((1834·38\pm0.35)\times10^{−7}\) c.g.s. units. \cite{majumdar1938coefficient})

Initially both are same as you can see in pictures (at \(t=0\)),
[[../images/t0.png]]
pendulum at \(t=0s\)

Now, as we look with increment in time we can see it deflecting slightly with it. This is picture at \(t = 100s\),

[[../images/t100.png]]
pendulum at \(t=100s\)

Here, red bob is exact solution (nonlinear equation) where green is linear equations solution.

For more information, i gave all my code in appendix and also in my github page [[https://github.com/vijaypanchalr3][vijaypanchalr3]].

*** Equation of motion with quadratic damping
    :PROPERTIES:
    :CUSTOM_ID: sec:orgb335451
    :END:
    
Quadratic damping gives better approximations over as linear damping but also gives burden of nonlinearization. In equation \ref{eq:org2f6bde8} we can put value of quadratic damping approximation. 

\begin{equation*}
F_{damping}-mgsin(\theta)=ml\ddot{\theta}
\end{equation*}

We can put value of damping force as \(F_{damping} = -k_{q}l^{2}\theta^{2}\),

\begin{equation*}
-k_{q}l^{2}\theta^{2}-mgsin(\theta)=ml\ddot{\theta}
\end{equation*}

\begin{equation*}
\ddot{\theta}+\frac{k_{q}l}{m}\theta^{2}+\frac{g}{l}sin(\theta)=0
\end{equation*}

\begin{equation*}
\ddot{\theta}+\Gamma_{q}\theta^{2}+\frac{g}{l}sin(\theta)=0
\end{equation*}

This is also second order differential. Even with approximation this have still no close form solution. We will solve this numerically in simulation just see difference between linear damping.

* Results and conclusion
  :PROPERTIES:
  :CUSTOM_ID: sec:org883c01d
  :END:
As we seen earlier our simulations discuss how exact solution differs
from approximation. Also, we see that linear damping is still a
approximation and can be replaced by better approximation when medium
have turbulant flow by bob of our pendulum.

** Effect on angular frequency of pendulum with approximation and exact solution
   :PROPERTIES:
   :CUSTOM_ID: sec:org12c1446
   :END:
   
As we have seen in our simulation that in linear solution equation \ref{eq:orgfa1e4db}, we got single constant frequency with \(\theta\) but not in nonlinear one. Nonlinear equation has non constant frequency. We can see from graph of it that how it differs from constant frequency of linear solution. \cite{sobamowo2020exact} \cite{johannessen2014analytical}

#+caption: How angular frequency change with \(\theta_{0}\) in nonlinear
solution and shows constant at value \(\sqrt{\frac{g}{l}}\)
[[../images/angfre.png]]

** For different \(\theta_{0}\) it has different \(\theta(t)\)
   :PROPERTIES:
   :CUSTOM_ID: sec:org082cc5a
   :END:
Let's look at how our two solution exactly changes with time. For that
we took values of \(\theta\) on time scale and changed it's
\(\theta_{0}\).

#+caption: For different \(\theta\) we have completely different type of
solution
[[../images/thetawitht.png]]

** Hidden informations
   :PROPERTIES:
   :CUSTOM_ID: sec:orgbb72165
   :END:

Approximation not only affect in quantitatively but also sometimes qualitatively. Let's discuss part of that lost in approximation. Phase planes are geometrical procedures of obtaining properties of system (here solutions). If write our equation of motion for the pendulum from \ref{eq:org2f6bde8}.

\begin{equation*}
\label{eq:org58c086d}
F_{damping}-mgsin(\theta)=ml\ddot{\theta}
\end{equation*}

Here, \(F_{damping}\) is velocity depend term. Also, velocity \(v=l\dot{\theta}\). So, we can write equation \ref{eq:org2f6bde8} in following way,


\begin{equation*}
\label{eq:org2b0adac}
F_{d}(\dot{\theta})-mgsin(\theta)=ml\ddot{\theta}
\end{equation*}

Taking \(\phi=\dot{\theta}\) led to,

\begin{equation}
\label{eq:orgda8ae95}
\dot{\phi}=(\frac{1}{ml})F_{d}(\phi)-\frac{g}{l}sin(\theta)
\end{equation}

\begin{equation}
\label{eq:org96f7aea}
\dot{\theta} = P(\theta,\phi)
\end{equation}

\begin{equation}
\label{eq:org0b167d3}
\dot{\phi} = Q(\theta,\phi)
\end{equation}

Dividinge equation \ref{eq:org0b167d3} and \ref{eq:org96f7aea} will give us,

\begin{equation}
\label{eq:org244ac6d}
\frac{\dot{\phi}}{\dot{\theta}}= \frac{\frac{d(\phi)}{dt}}{\frac{d{\theta}}{dt}} = \frac{d\phi}{d\theta}= \frac{Q(\theta,\phi)}{P(\theta,\phi)}
\end{equation}

This equation \ref{eq:org244ac6d} will give \textbf{phase trajectory} of our system. By, equation \ref{eq:orgda8ae95} value of \(\phi\) gives,

\begin{equation}
\label{eq:orgfab4e08}
\frac{d\phi}{d\theta}=\frac{(\frac{1}{ml})F_{d}(\phi)-\frac{g}{l}sin(\theta)}{phi}
\end{equation}

In equation \ref{eq:orgfab4e08} if we put value of \(F_{d} = k_{l}l\dot{\theta} = k_{l}l\phi\) for linear damping damping force, we will get,

\begin{equation}
\label{eq:org3af6856}
\frac{d\phi}{d\theta}=\frac{\Gamma\phi-\frac{g}{l}sin(\theta)}{phi}
\end{equation}

This is our equation of motion which give trajectory for exact solution and similarly approximated solution would be,

\begin{equation}
\label{eq:org7e12b82}
\frac{d\phi}{d\theta}=\frac{\Gamma\phi-\frac{g}{l}\theta}{phi}
\end{equation}

Ploting this two will give two distinct phase planes which gives important properties of system. Two phase plane plots are as following, 

#+caption: This is phase plane of approximate solution where we took
\(sin(\theta) \to \theta\). here you can see big vortex.
[[../images/approlstr.png]]

#+caption: This is phase plane of exact solution without previous
approximation.
[[../images/exactlstr.png]]

As we can see that in approximated equation we have only one big vortex.
In contrast to that we have vortexs with lines.

In first figure in approximated equation we have phase trajectory of
simplest, spiral. This suggest a simple harmonic motion which will
always have stable and periodic motion.

In second figure we got completely different phase trajectory. We got
three are with completely different behavior of system. The three cases
of it are following,

In first area, which is vortex like previous has stable and periodic
with energy \(E<2mgl\), second area we got *seddle point*, in which we
got unstable and aperiodic motion \(E=2mgl\). In last area which is
upper and lower part of plot are just lines, this are shows circular
motion around pivot of string with wall. Energy for this kind of motion
is \( E>2mgl \).

* Appendix
  :PROPERTIES:
  :CUSTOM_ID: sec:orgdf11517
  :END:
** Runge-Kutta 4th order method
   :PROPERTIES:
   :CUSTOM_ID: sec:org405d12c
   :END:
In our this simulation we made use of Range Kutta fourth order method as numerical method for solving non-linear differential equation and linear differential equation with it. So, it is good idea to understand what is Range-Kutta fourth order method and how can we implement to solve present differential equations.

Runge Kutta Method is not predictor-corrector method like other numerical method (namely, modified Euler method, Adams-Bashmoth-Moulton method) for solving differential equation. It uses four different new variables and then simply addition and multiplication predict our initial value problem with good accuracy.

We can use RK method in following manor,

\begin{equation*}
y_{n+1} = y_{n}+\frac{1}{6}(k_{1}+2k_{2}+2k_{3}+k_{4})
\end{equation*}

\begin{equation*}
z_{n+1} = z_{n}+\frac{1}{6}(l_{1}+2l_{2}+2l_{3}+l_{4})
\end{equation*}

Where,
\begin{equation*}
k_{1}=hf(x_{n},y_{n},z_{n})
\end{equation*}
\begin{equation*}
l_{1}=hg(x_{n},y_{n},z_{n})
\end{equation*}
\begin{equation*}
k_{2}=hf(x_{n}+\frac{h}{2},y_{n}+\frac{k_{1}}{2},z_{n}+\frac{l_{1}}{2})
\end{equation*}
\begin{equation*}
l_{2}=hg(x_{n}+\frac{h}{2},y_{n}+\frac{k_{1}}{2},z_{n}+\frac{l_{1}}{2})
\end{equation*}
\begin{equation*}
k_{3}=hf(x_{n}+\frac{h}{2},y_{n}+\frac{k_{2}}{2},z_{n}+\frac{l_{2}}{2})
\end{equation*}
\begin{equation*}
l_{3}=hg(x_{n}+\frac{h}{2},y_{n}+\frac{k_{2}}{2},z_{n}+\frac{l_{2}}{2})
\end{equation*}
\begin{equation*}
k_{4}=hf(x_{n}+h,y_{n}+k_{3},z_{n}+l_{2})
\end{equation*}
\begin{equation*}
l_{4}=hg(x_{n}+h,y_{n}+k_{3},z_{n}+l_{2})
\end{equation*}

Where, \(h\) is step and \(f,g\) are two complimetry function, in our purpose we used \(f = \theta\) and \(f = \phi\).


** Simulation code
   :PROPERTIES:
   :CUSTOM_ID: sec:org14579d6
   :END:
Now, come animation part. Which we basically used *pygame* in *python*.
We first get array of both solutions with interval of
\(\frac{1}{60} second\) and give this data in position function in my
/main.py/ file which just use convert each to the Cartesian coordinates
from initial Polar coordinate. This is because /pygame/ screen
rectangular coordinates with units in pixel of
screen.[[https://github.com/pygame/pygame]]

Following data, we used as constant which i defined in /constant.py/
file, as per close inspection you can see that we used C.G.S. units
because of better visual on computer screen. Remember, we made this code
for reconstruct purpose only.

My /constant.py/ file

#+begin_src python
  from math import sqrt

  # defining constants in C.G.S.

  pi = 3.141592
  width,height = 1360,720         # pygame window size in pixel units
  origin_x,origin_y = width/2,height/8 # setting up the origin O

  # density
  rho = 0.001293

  # newton's drag coefficient
  cd = 0.47

  # diameter
  d = 0.05

  # mass 
  m = 500

  # length of string
  l = 500

  # gravitation accelaration
  g = 980

  # viscosity of air
  eta = 0.0001834

  kl = 3*pi*eta*d
  kq = (1/8)*pi*cd*rho*d*d

  gammal = (kl*l)/m
  gammaq = (kq*l)/m
  w0 = sqrt(g/l)                  # natural frequncy of SHM
  theta_initial = 3.141592/10      # initial theta in radian
  radius = 10                     # radius of ball in pixel
  fps = 120                        # frame per second


#+end_src

This is my /main.py/ file, in which i defined all functions for
calculations. In which, i have Runge-Kutta method defined and solution
and also phase planes defined.

#+begin_src python
import pygame as pg
from numpy import format_float_scientific, sin,cos,pi,sqrt
import os
import sys



def load_image(image):
    fullname = os.path.join("./", image)
    image = pg.image.load(fullname)
    # image = pg.image.load(fullname).convert()
    # image.set_colorkey((255, 255, 255), pg.RLEACCEL)
    # image = pg.transform.scale(image, (20, 20))
    return image

def resource_path(relative_path):
    try:
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(".")

    return os.path.join(base_path, relative_path)

class Pendulum:
    def __init__(self,length,mass,dampcoef,gravity,theta,phi,color="#000000",image = "bitmap.png"):
        self.length = length
        self.w0 = gravity/length
        self.gamma = (length*dampcoef)/mass
        self.T = ((sqrt(length/gravity))*(1+(0.25*(sin(0.5*theta))**2)+((9/64)*(sin(theta*0.5))**4)))*2*pi
        self.W = (2*pi)/self.T
        self.theta = theta
        self.phi = phi
        self.color = color
        self.mass = mass
        self.gravity = gravity
        self.E0 = 0.5*self.mass*phi*phi+self.mass*self.gravity*self.length*(1-cos(theta))
        self.h = 0.0150
        self.image = load_image(image)
    def Auxilaryfun(self,theta,phi):
        return -(self.gamma*phi)-(self.w0*sin(theta))

    def update(self):
        """

        """
        k1 = self.h*self.phi
        l1 = self.h*self.Auxilaryfun(self.theta,self.phi)
        k2 = self.h*(self.phi+(l1*0.5))
        l2 = self.h*self.Auxilaryfun(self.theta+(k1*0.5),self.phi+(l1*0.5))
        k3 = self.h*(self.phi+(l2*0.5))
        l3 = self.h*(self.Auxilaryfun(self.theta+(k2*0.5),self.phi+(l2*0.5)))
        k4 = self.h*(self.phi+l3)
        l4 = self.h*(self.Auxilaryfun(self.theta+k3,self.phi+l3))
        k_ = (1/6)*(k1+k4+2*(k2+k3))
        l_ = (1/6)*(l1+l4+2*(l2+l3))
        self.theta+=k_
        self.phi+=l_
    def timeperiod(self):
        return self.T,self.W
    def energy(self):
        T = 0.5*self.mass*self.length*self.length*self.phi*self.phi
        V = self.mass*self.gravity*self.length*(1-cos(self.theta))
        return T,V,T+V
    def initial_E(self):
        return self.E0
        

    def draw(self,screen,origin):
        """
        
        """
        x=origin[0]+(self.length*cos((pi*1.5)+self.theta))
        y=origin[1]-(self.length*sin((pi*1.5)+self.theta))
        pg.draw.aaline(screen,self.color,start_pos=origin,end_pos=(x,y))
        screen.blit(self.image,(x-10,y-10))


class PendulumAppro(Pendulum):
    def __init__(self, length, mass, dampcoef, gravity, theta, phi, image,color="#000000"):
        super().__init__(length, mass, dampcoef, gravity, theta, phi,image=image,color=color)

    def Auxilaryfun(self, theta, phi):
        return -(self.gamma*phi)-(self.w0*theta)


    
    def timeperiod(self):
        W = sqrt(self.gravity/self.length)
        T = (2*pi)/W
        return T,W


class DoublePendulum:
    """

    """
    def __init__(self,mass1,mass2,length1,length2,dampcoef,gravity,theta1,theta2,phi1,phi2,image="bitmap1.png",color="#000000"):
        self.mass1 = mass1
        self.mass2 = mass2
        self.length1 = length1
        self.length2 = length2
        self.gravity = gravity
        self.theta1 = theta1
        self.theta2 = theta2
        self.phi1 = phi1
        self.phi2 = phi2
        self.h = 0.0150
        self.origin = (650,200)
        self.image = load_image("bitmap1.png")
        self.color = color
        
        
        self.l1sq_m1_by2 = 0.5*self.mass1*self.length1**2
        self.l1sq_m2_by2 = 0.5*self.mass2*self.length1**2
        self.l2sq_m2_by2 = 0.5*self.mass2*self.length2**2
        self.l1_l2_m2 = self.length1*self.length2*self.mass2
        T = self.l1sq_m1_by2*self.phi1*self.phi1+self.l1sq_m2_by2*self.phi1*self.phi1+self.l2sq_m2_by2*self.phi2*self.phi2+self.l1_l2_m2*self.phi1*self.phi2*cos(self.theta1-self.theta2)
        V = 2*self.mass1*self.length1*self.gravity+self.mass2*self.length2*self.gravity-(self.mass1+self.mass2)*self.gravity*self.length1*cos(self.theta1)-self.mass2*self.gravity*self.length2*cos(self.theta2)
        self.E0 = T+V


    def oxillary1(self,theta1,theta2,phi1,phi2):
        diff = theta1-theta2
        return (((-2*sin(diff)*self.mass2*(phi1*phi1*self.length1*cos(diff)+phi2*phi2*self.length2))-self.gravity*(2*self.mass2+self.mass1)*sin(theta1)-self.gravity*self.mass2*sin(theta1-2*theta2))/(self.length1*(2*self.mass1+self.mass2-self.mass2*cos(2*diff))))

    def oxillary2(self,theta1,theta2,phi1,phi2):
        diff = theta1-theta2
        return ((2*sin(diff)*(phi1*phi1*self.length1*(self.mass1+self.mass2)+self.gravity*(self.mass1+self.mass2)*cos(theta1)+phi2*phi2*self.length2*self.mass2*cos(diff)))/(self.length2*(2*self.mass1+self.mass2-self.mass2*cos(2*diff))))


    def update(self):
        """

        Runge kutta methods
        """
        k11 = self.h*self.phi1
        k12 = self.h*self.phi2
        l11 = self.h*self.oxillary1(self.theta1,self.theta2,self.phi1,self.phi2)
        l12 = self.h*self.oxillary2(self.theta1,self.theta2,self.phi1,self.phi2)
        k21 = self.h*(self.phi1+(l11*0.5))
        k22 = self.h*(self.phi2+(l12*0.5))
        l21 = self.h*self.oxillary1(self.theta1+(k11*0.5),self.theta2+(k12*0.5),self.phi1+(l11*0.5),self.phi2+(l12*0.5))
        l22 = self.h*self.oxillary2(self.theta1+(k11*0.5),self.theta2+(k12*0.5),self.phi1+(l11*0.5),self.phi2+(l12*0.5))
        k31 = self.h*(self.phi1+(l21*0.5))
        k32 = self.h*(self.phi2+(l22*0.5))
        l31 = self.h*self.oxillary1(self.theta1+(k21*0.5),self.theta2+(k22*0.5),self.phi1+(l21*0.5),self.phi2+(l22*0.5))
        l32 = self.h*self.oxillary2(self.theta1+(k21*0.5),self.theta2+(k22*0.5),self.phi1+(l21*0.5),self.phi2+(l22*0.5))
        k41 = self.h*(self.phi1+l31)
        k42 = self.h*(self.phi2+l32)
        l41 = self.h*self.oxillary1(self.theta1+k31,self.theta2+k32,self.phi1+l31,self.phi2+l32)
        l42 = self.h*self.oxillary2(self.theta1+k31,self.theta2+k32,self.phi1+l31,self.phi2+l32)
        k_1 = (1/6)*(k11+k41+2*(k21+k31))
        k_2 = (1/6)*(k21+k42+2*(k22+k32))
        l_1 = (1/6)*(l11+l41+2*(l21+l31))
        l_2 = (1/6)*(l12+l42+2*(l22+l32))

        self.theta1+=k_1
        self.theta2+=k_2
        self.phi1+=l_1
        self.phi2+=l_2
    def initial_energy(self):
        return self.E0    
    def energy(self):
        T = self.l1sq_m1_by2*self.phi1*self.phi1+self.l1sq_m2_by2*self.phi1*self.phi1+self.l2sq_m2_by2*self.phi2*self.phi2+self.l1_l2_m2*self.phi1*self.phi2*cos(self.theta1-self.theta2)
        V = 2*self.mass1*self.length1*self.gravity+self.mass2*self.length2*self.gravity-(self.mass1+self.mass2)*self.gravity*self.length1*cos(self.theta1)-self.mass2*self.gravity*self.length2*cos(self.theta2)
        E = T+V
        return T,V,E

    def draw(self,window):
        x1 = self.origin[0]+self.length1*cos((pi*1.5)-self.theta1)
        y1 = self.origin[1]-self.length1*sin((pi*1.5)-self.theta1)
        x2 = x1+self.length2*cos((pi*1.5)-self.theta2)
        y2 =y1-self.length2*sin((pi*1.5)-self.theta2)
        pg.draw.aaline(window,self.color,start_pos=self.origin,end_pos=(x1,y1))
        pg.draw.aaline(window,self.color,start_pos=(x1,y1),end_pos=(x2,y2))
        window.blit(self.image,(x1-10,y1-10))
        window.blit(self.image,(x2-10,y2-10))

class theme:
    def __init__(self):
        color1 = "#FFF5E4"
        color2 = "#EE6983"
        color3 = "#FFC4C4"
        color4 = "#111111"
        color5 = "#FFC2A2"
        self.ff=pg.font.Font("Lato-BoldItalic.ttf",24)
        self.ff2=pg.font.Font("Lato-BoldItalic.ttf",32)
        self.fg = color4
        self.bg = color1
        self.special = color3
        self.common = color2
        self.extra = color5
    def slider(self,x,y,pos):
        cursor = pg.mouse.get_pos()
        clicked_pos = pg.mouse.get_pressed()
        # active = false
        pg.draw.rect(self.window,self.common,(x,y,200,2))
        pg.draw.circle(self.window,self.special,(pos+x-5,y),15)
        if x+200>cursor[0]>=x and y+25>=cursor[1]>=y-25:
            if clicked_pos[0]==1:
                pg.draw.circle(self.window,self.extra,(pos+x-5,y),15)
                pos = cursor[0]-x
        return pos
    def Heading1(self,title_text,x,y,foreground):
        text = self.ff2.render(title_text,True,foreground,self.bg)
        text_size = text.get_size()
        text_rect = pg.draw.rect(self.window,self.bg,(x-text_size[0]//2,y-text_size[1]//2,text_size[0]+20,text_size[1]+10),border_radius=border_radius)
        self.window.blit(text,(text_rect.x+10,text_rect.y+5))

    def button_with_shadow(self,button_text,x,y,background,foreground,shadow_color,font,hover_color="#ffffff",border_radius=5,shadow_distance=5):
        hover_color=self.extra
        text = font.render(button_text,True,foreground,background)
        text_size = text.get_size()
        text_rect = pg.Rect(x-text_size[0]//2,y-text_size[1]//2,text_size[0]+20,text_size[1]+10)
        # text_rect = pg.draw.rect(self.window,background,(x-text_size[0]//2,y-text_size[1]//2,text_size[0]+20,text_size[1]+10),border_radius=border_radius)
        cursor = pg.mouse.get_pos()
        pg.draw.rect(self.window,shadow_color,(x-text_size[0]//2+shadow_distance,y-text_size[1]//2+shadow_distance,text_size[0]+20,text_size[1]+10),border_radius=border_radius)
        if text_rect.collidepoint(pg.mouse.get_pos()):
            text = font.render(button_text,True,foreground,hover_color)
            text_rect = pg.draw.rect(self.window,hover_color,(x-text_size[0]//2+1,y-text_size[1]//2+1,text_size[0]+20,text_size[1]+10),border_radius=border_radius)
        else:
            text_rect = pg.draw.rect(self.window,background,(x-text_size[0]//2,y-text_size[1]//2,text_size[0]+20,text_size[1]+10),border_radius=border_radius)
        self.window.blit(text,(text_rect.x+10,text_rect.y+5))
        return text_rect

    def text_left(self,text,x,y,background,foreground,font):
        text = font.render(text,True,foreground,background)
        text_size = text.get_size()
        text_rect = pg.draw.rect(self.window,background,(x,y,text_size[0]+20,text_size[1]+10))
        self.window.blit(text,(text_rect.x+10,text_rect.y+5))

    def back_button(self,size):
        # text = self.ff2.render("X",True,self.fg,self.common)
        # self.window.blit(text,(text_rect.x+10,text_rect.y+8))
        text_rect = pg.draw.rect(self.window,self.common,(size[0]-80,40,40,40),border_radius=5)
        pg.draw.circle(self.window,self.bg,(text_rect.x+20,text_rect.y+20),15,5)
        return text_rect

    def bar(self,x,y,initial_val,new_val):
        pg.draw.rect(self.window,self.special,(x,y,300,15))
        pg.draw.rect(self.window,self.common,(x,y,300*new_val/initial_val,15))

    def inputbox(self,text,input_text,x,y,maximum,activity,background,foreground,active_color,inactive_color,font):
        text = font.render(text,True,foreground,background)
        text_size = text.get_size()
        text_rect = pg.draw.rect(self.window,background,(x,y,text_size[0]+20,text_size[1]+10))
        self.window.blit(text,text_rect)
        if activity:
            text_surface = font.render(input_text, True, foreground,active_color)
            input_rect = pg.Rect(x+text_size[0]+50,y,max(maximum,text_surface.get_width()+10),text_size[1])  
            pg.draw.rect(self.window,active_color,input_rect)
        else:
            text_surface = font.render(input_text, True, foreground,inactive_color)
            input_rect = pg.Rect(x+text_size[0]+50,y,max(maximum,text_surface.get_width()+10),text_size[1])  
            pg.draw.rect(self.window,inactive_color,input_rect)
        self.window.blit(text_surface,input_rect)
        return input_rect

    
class Simulation(theme):
    def __init__(self):
        pg.init()
        self.window = pg.display.set_mode((1360,720),pg.RESIZABLE)
        self.size =self.window.get_size()
        pg.display.set_caption("Pendulum simulation")    
        super().__init__()

        self.length1 = 200
        self.lengtho1 = self.length1
        self.length2 = 200
        self.lengtho2 = self.length2
        self.mass1 = 100
        self.masso1 = self.mass1
        self.mass2 = 100
        self.masso2 = self.mass2
        self.dampcoef = 0.0
        self.dampcoefo =self.dampcoef
        self.gravity = 980
        self.gravityo = self.gravity
        self.theta1 = 0.550
        self.thetao1 = self.theta1
        self.theta2 = 0.550
        self.thetao2 = self.theta2
        self.phi1 = 0.0
        self.phio1 = self.phi1
        self.phi2 = 0.0
        self.phio2 = self.phi2
    
        
    def mainmenu(self):
        run = True
        clock = pg.time.Clock()
        heading_rect = self.button_with_shadow("Welcome to C.M. simulation app",self.size[0]//2,100,self.special,self.fg,self.common,self.ff2)
        # heading_rect = pg.draw.rect(self.window,self.special,(self.size[0]//2-heading_size[0]//2,50,heading_size[0]+20,heading_size[1]+10),border_radius=5)

        exit_rect = self.button_with_shadow("exit",self.size[0]//2,self.size[1]-100,self.special,self.fg,self.common,self.ff2)

        option1 = self.ff2.render("Single pendulum",True,self.fg,self.special)
        option1_size = option1.get_size()
        option1_rect = pg.draw.rect(self.window,self.special,(self.size[0]//2-200-50,self.size[1]//2-250,200,100),border_radius=15)
        option21 = self.ff2.render("Double pendulum",True,self.fg,self.special)
        option22 = self.ff2.render("(chaotic system)",True,self.fg,self.special)
        option2_rect = pg.draw.rect(self.window,self.special,(self.size[0]//2-200-50,self.size[1]//2-250,200,100),border_radius=15)
        option3 = self.ff2.render("Coupled pendulum",True,self.fg,self.special)
        option3_rect = pg.draw.rect(self.window,self.special,(self.size[0]//2+50,self.size[1]//2-250,200,100),border_radius=15)
        while run:
            for event in pg.event.get():
                if event.type == pg.QUIT:
                    run = False
                    sys.exit()

                if event.type == pg.MOUSEBUTTONDOWN:
                    if option1_rect.collidepoint(event.pos):
                        self.menuS()
                    if option2_rect.collidepoint(event.pos):
                        self.menuD()
                    if exit_rect.collidepoint(event.pos):
                        run = False
                        sys.exit()
        
            clock.tick(60)
            self.window.fill(self.bg)
            self.size = self.window.get_size()
            
            pg.draw.rect(self.window,self.common,(self.size[0]//2-300+5,self.size[1]//2-145,300,150),border_radius=15)
            option1_rect = pg.draw.rect(self.window,self.special,(self.size[0]//2-300,self.size[1]//2-150,300,150),border_radius=15)

            pg.draw.rect(self.window,self.common,(self.size[0]//2+55,self.size[1]//2-145,300,150),border_radius=15)
            option2_rect = pg.draw.rect(self.window,self.special,(self.size[0]//2+50,self.size[1]//2-150,300,150),border_radius=15)

            pg.draw.rect(self.window,self.common,(self.size[0]//2-300+5,self.size[1]//2+55,300,150),border_radius=15)
            option3_rect = pg.draw.rect(self.window,self.special,(self.size[0]//2-300,self.size[1]//2+50,300,150),border_radius=15)

            heading_rect = self.button_with_shadow("Welcome to C.M. Simulation app",self.size[0]//2,100,self.special,self.fg,self.common,self.ff2)
            exit_rect = self.button_with_shadow("exit",self.size[0]//2,self.size[1]-100,self.special,self.fg,self.common,self.ff2)


            self.window.blit(option1,(option1_rect.x+35,option1_rect.y+50))
            self.window.blit(option21,(option2_rect.x+35,option2_rect.y+30))
            self.window.blit(option22,(option2_rect.x+40,option2_rect.y+70))
            self.window.blit(option3,(option3_rect.x+25,option3_rect.y+50))
            pg.display.flip()


        pg.quit()
            
        
    def menuD(self):
        run = True
        clock = pg.time.Clock()
        self.size = self.window.get_size()

        self.length1 = 200
        self.length2 = 200
        self.lengtho1 = 200
        self.lengtho2 = 200
        

        back_button = self.back_button(self.size)
        heading_rect = self.button_with_shadow("Double pendulum",self.size[0]//2,100,self.special,self.fg,self.common,self.ff2)
        back_rect = self.button_with_shadow("back",self.size[0]//2-200,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
        reset_rect = self.button_with_shadow("reset",self.size[0]//2,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
        run_rect = self.button_with_shadow("run",self.size[0]//2+200,self.size[1]-100,self.special,self.fg,self.common,self.ff2)


        length1 = self.length1
        length2 = self.length2
        mass1 = self.mass1
        mass2 = self.mass2
        dampcoef = self.dampcoef
        gravity = self.gravity
        theta1 = self.theta1
        theta2 = self.theta2
        phi1 = self.phi1
        phi2 = self.phi2


        
        pos1 = length1/10-1
        pos2 = length2/10-1
        pos3 = (mass1-20)/20
        pos4 = (mass2-20)/20
        # pos5 = dampcoef*2
        pos5 = gravity/100

        active1 = False
        active2 = False
        active3 = False
        active4 = False

        user_text1 = str(theta1)
        user_text2 = str(theta2)
        user_text3 = str(phi1)
        user_text4 = str(phi2)


        color_active = self.special
        color_inactive = self.common

        
        input_rect1 = self.inputbox("initial displacement 1= ",input_text=str(user_text1),x=100,y=330,maximum=200,activity=active1,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
        input_rect2 = self.inputbox("initial displacement 2 = ",input_text=str(user_text2),x=100,y=380,maximum=200,activity=active2,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
        input_rect3 = self.inputbox("initial angular velocity 1 = ",input_text=str(user_text3),x=100,y=430,maximum=200,activity=active3,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
        input_rect4 = self.inputbox("initial angular velocity 2 = ",input_text=str(user_text4),x=100,y=480,maximum=200,activity=active4,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
        one_pen_rect = self.button_with_shadow("one system",self.size[0]//2,self.size[1]-200,self.extra,self.fg,self.common,self.ff,shadow_distance=2)
        two_pen_rect = self.button_with_shadow("two systems",self.size[0]//2+300,self.size[1]-200,self.special,self.fg,self.common,self.ff)

        


        while run:
            for event in pg.event.get():
                if event.type==pg.QUIT:
                    run = False
                    sys.exit()

                if event.type==pg.KEYDOWN:
                    if active1:
                        if event.key==pg.K_BACKSPACE:
                            user_text1=user_text1[:-1]
                        else:
                            if event.key==pg.K_RETURN or event.key==pg.K_KP_ENTER:
                                active1=False
                                try:
                                    theta1 = float(user_text1)
                                except:
                                    user_text1 = str(theta1)
                            else:
                                user_text1+=event.unicode
                    elif active2:
                        if event.key==pg.K_BACKSPACE:
                            user_text2=user_text2[:-1]
                        else:
                            if event.key==pg.K_RETURN or event.key==pg.K_KP_ENTER:
                                active2=False
                                try:
                                    theta2 = float(user_text2)
                                except:
                                    user_text2 = str(theta2)
                            else:
                                user_text2+=event.unicode

                    elif active3:
                        if event.key==pg.K_BACKSPACE:
                            user_text3=user_text3[:-1]
                        else:
                            if event.key==pg.K_RETURN or event.key==pg.K_KP_ENTER:
                                active3=False
                                try:
                                    phi1 = float(user_text3)
                                except:
                                    user_text3 = str(phi1)
                            else:
                                user_text3+=event.unicode

                    elif active4:
                        if event.key==pg.K_BACKSPACE:
                            user_text4=user_text4[:-1]
                        else:
                            if event.key==pg.K_RETURN or event.key==pg.K_KP_ENTER:
                                active4=False
                                try:
                                    phi2 = float(user_text4)
                                except:
                                    user_text4 = str(phi2)
                            else:
                                user_text4+=event.unicode

                    else:
                        user_text = "0.0"
                if event.type==pg.MOUSEBUTTONDOWN:
                    if input_rect1.collidepoint(event.pos):
                        active1 = True
                        active2 = False
                        active3 = False
                        active4 = False
                    if input_rect2.collidepoint(event.pos):
                        active1 = False
                        active2 = True
                        active3 = False
                        active4 = False
                    if input_rect3.collidepoint(event.pos):
                        active1 = False
                        active2 = False
                        active3 = True
                        active4 = False
                    if input_rect4.collidepoint(event.pos):
                        active1 = False
                        active2 = False
                        active3 = False
                        active4 = True
                    if back_button.collidepoint(event.pos):
                        run = False
                        break
                    if two_pen_rect.collidepoint(event.pos):
                        self.length1 = length1
                        self.length2 = length2
                        self.mass1 = mass1
                        self.mass2 = mass2
                        # self.dampcoef = dampcoef
                        self.gravity = gravity
                        self.menuD2()
                    if run_rect.collidepoint(event.pos):
                        self.length1 = length1
                        self.length2 = length2
                        self.mass1 = mass1
                        self.mass2 = mass2
                        # self.dampcoef = dampcoef
                        self.gravity = gravity
                        self.theta1 = theta1
                        self.theta2 = theta2
                        self.phi1 = phi1
                        self.phi2 = phi2
                        self.runD1()
                    if back_rect.collidepoint(event.pos):
                        run = False
                        break
                    if reset_rect.collidepoint(event.pos):
                        pos1 = (self.lengtho1/10)-1
                        pos2 = (self.lengtho2/10)-1
                        pos3 = (self.masso1-20)/20
                        pos4 = (self.masso2-20)/20
                        # pos5 = self.dampcoefo*2
                        pos5 = self.gravityo/100
                        theta1 = self.thetao1
                        theta2 = self.thetao2
                        phi1 = self.phio1
                        phi2 = self.phio2
                        user_text1 = str(theta1)
                        user_text2 = str(theta2)
                        user_text3 = str(phi1)
                        user_text4 = str(phi2)
            clock.tick(120)
            self.window.fill(self.bg)
            self.size = self.window.get_size()

            back_button = self.back_button(self.size)
            heading_rect = self.button_with_shadow("Double pendulum",self.size[0]//2,100,self.special,self.fg,self.common,self.ff2)
            back_rect = self.button_with_shadow("back",self.size[0]//2-200,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
            reset_rect = self.button_with_shadow("reset",self.size[0]//2,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
            run_rect = self.button_with_shadow("run",self.size[0]//2+200,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
            one_pen_rect = self.button_with_shadow("one system",self.size[0]//2+100,self.size[1]-300,self.extra,self.fg,self.common,self.ff,shadow_distance=2)
            two_pen_rect = self.button_with_shadow("two systems",self.size[0]//2+400,self.size[1]-300,self.special,self.fg,self.common,self.ff)


            
            # rectangle drawing
            
            self.text_left("length 1=   "+str(round(length1)),90,170,self.bg,self.fg,self.ff)
            pos1 = self.slider(self.size[0]//2-250,170+20,pos1)
            length1 = round((pos1*10)+10)


            pos2 = self.slider(self.size[0]-250,170+20,pos2)
            length2 = round((pos2*10)+10)
            self.text_left("length 2=   "+str(round(length2)),self.size[0]//2,170,self.bg,self.fg,self.ff)

            pos3 = self.slider(self.size[0]//2-250,220+20,pos3)
            mass1 = round(pos3*20+20)
            self.text_left("mass 1=   "+str(round(mass1)),90,220,self.bg,self.fg,self.ff)

            pos4 = self.slider(self.size[0]-250,220+20,pos4)
            mass2 = round(pos4*20+20)
            self.text_left("mass 2=   "+str(round(mass2)),self.size[0]//2,220,self.bg,self.fg,self.ff)

            # pos5 = self.slider(self.size[0]//2-250,270+20,pos5)
            # dampcoef = round(pos5/200,3)
            # self.text_left("damp coeffciant =   "+str(dampcoef),100,270,self.bg,self.fg,self.ff)

            pos5 = self.slider(self.size[0]//2-250,270+20,pos5)
            gravity = round(10*pos5)+882
            self.text_left("gravity=   "+str(round(gravity)),90,270,self.bg,self.fg,self.ff)

            
            input_rect1 = self.inputbox("initial displacement 1= ",input_text=str(user_text1),x=100,y=330,maximum=200,activity=active1,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
            input_rect2 = self.inputbox("initial displacement 2 = ",input_text=str(user_text2),x=100,y=380,maximum=200,activity=active2,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
            input_rect3 = self.inputbox("initial angular velocity 1 = ",input_text=str(user_text3),x=100,y=430,maximum=200,activity=active3,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
            input_rect4 = self.inputbox("initial angular velocity 2 = ",input_text=str(user_text4),x=100,y=480,maximum=200,activity=active4,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)

            
            pg.display.flip()

    def menuD2(self):
        run = True
        clock = pg.time.Clock()
        self.size = self.window.get_size()
        back_button = self.back_button(self.size)
        back_button = self.back_button(self.size)
        heading_rect = self.button_with_shadow("Simple pendulum",self.size[0]//2,100,self.special,self.fg,self.common,self.ff2)
        back_rect = self.button_with_shadow("back",self.size[0]//2-200,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
        reset_rect = self.button_with_shadow("reset",self.size[0]//2,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
        run_rect = self.button_with_shadow("run",self.size[0]//2+200,self.size[1]-100,self.special,self.fg,self.common,self.ff2)

        theta11 = self.theta1
        theta21 = self.theta2
        phi11 = self.phi1
        phi21 = self.phi2
        theta12 = self.theta1
        theta22 = self.theta2
        phi12 = self.phi1
        phi22 = self.phi2


        
        active1 = False
        active2 = False
        active3 = False
        active4 = False
        active5 = False
        active6 = False
        active7 = False
        active8 = False

        user_text1 = str(theta11)
        user_text2 = str(theta21)
        user_text3 = str(phi11)
        user_text4 = str(phi21)
        user_text5 = str(theta12)
        user_text6 = str(theta22)
        user_text7 = str(phi12)
        user_text8 = str(phi22)


        color_active = self.special
        color_inactive = self.common

        while run:
            for event in pg.event.get():
                if event.type==pg.QUIT:
                    run = False
                    sys.exit()
                if event.type==pg.KEYDOWN:
                    if active1:
                        if event.key==pg.K_BACKSPACE:
                            user_text1=user_text1[:-1]
                        else:
                            if event.key==pg.K_RETURN or event.key==pg.K_KP_ENTER:
                                active1=False
                                try:
                                    theta11 = float(user_text1)
                                except:
                                    user_text1 = str(theta11)
                            else:
                                user_text1+=event.unicode
                    elif active2:
                        if event.key==pg.K_BACKSPACE:
                            user_text2=user_text2[:-1]
                        else:
                            if event.key==pg.K_RETURN or event.key==pg.K_KP_ENTER:
                                active2=False
                                try:
                                    theta21 = float(user_text2)
                                except:
                                    user_text2 = str(theta21)
                            else:
                                user_text2+=event.unicode

                    elif active3:
                        if event.key==pg.K_BACKSPACE:
                            user_text3=user_text3[:-1]
                        else:
                            if event.key==pg.K_RETURN or event.key==pg.K_KP_ENTER:
                                active3=False
                                try:
                                    phi11 = float(user_text3)
                                except:
                                    user_text3 = str(phi11)
                            else:
                                user_text3+=event.unicode

                    elif active4:
                        if event.key==pg.K_BACKSPACE:
                            user_text4=user_text4[:-1]
                        else:
                            if event.key==pg.K_RETURN or event.key==pg.K_KP_ENTER:
                                active4=False
                                try:
                                    phi21 = float(user_text4)
                                except:
                                    user_text4 = str(phi21)
                            else:
                                user_text4+=event.unicode
                    elif active5:
                        if event.key==pg.K_BACKSPACE:
                            user_text5=user_text5[:-1]
                        else:
                            if event.key==pg.K_RETURN or event.key==pg.K_KP_ENTER:
                                active5=False
                                try:
                                    theta12 = float(user_text5)
                                except:
                                    user_text5 = str(theta12)
                            else:
                                user_text5+=event.unicode
                    elif active6:
                        if event.key==pg.K_BACKSPACE:
                            user_text6=user_text6[:-1]
                        else:
                            if event.key==pg.K_RETURN or event.key==pg.K_KP_ENTER:
                                active6=False
                                try:
                                    theta22 = float(user_text6)
                                except:
                                    user_text6 = str(theta22)
                            else:
                                user_text6+=event.unicode

                    elif active7:
                        if event.key==pg.K_BACKSPACE:
                            user_text7=user_text7[:-1]
                        else:
                            if event.key==pg.K_RETURN or event.key==pg.K_KP_ENTER:
                                active7=False
                                try:
                                    phi12 = float(user_text7)
                                except:
                                    user_text7 = str(phi12)
                            else:
                                user_text7+=event.unicode

                    elif active8:
                        if event.key==pg.K_BACKSPACE:
                            user_text8=user_text8[:-1]
                        else:
                            if event.key==pg.K_RETURN or event.key==pg.K_KP_ENTER:
                                active8=False
                                try:
                                    phi22 = float(user_text8)
                                except:
                                    user_text8 = str(phi22)
                            else:
                                user_text8+=event.unicode
                    else:
                        user_text = "0.0"
                if event.type==pg.MOUSEBUTTONDOWN:
                    if input_rect1.collidepoint(event.pos):
                        active1 = True
                        active2 = False
                        active3 = False
                        active4 = False
                        active5 = False
                        active6 = False
                        active7 = False
                        active8 = False
                    if input_rect2.collidepoint(event.pos):
                        active1 = False
                        active2 = True
                        active3 = False
                        active4 = False
                        active5 = False
                        active6 = False
                        active7 = False
                        active8 = False
                    if input_rect3.collidepoint(event.pos):
                        active1 = False
                        active2 = False
                        active3 = True
                        active4 = False
                        active5 = False
                        active6 = False
                        active7 = False
                        active8 = False
                    if input_rect4.collidepoint(event.pos):
                        active1 = False
                        active2 = False
                        active3 = False
                        active4 = True
                        active5 = False
                        active6 = False
                        active7 = False
                        active8 = False
                    if input_rect5.collidepoint(event.pos):
                        active1 = False
                        active2 = False
                        active3 = False
                        active4 = False
                        active5 = True
                        active6 = False
                        active7 = False
                        active8 = False
                    if input_rect6.collidepoint(event.pos):
                        active1 = False
                        active2 = False
                        active3 = False
                        active4 = False
                        active5 = False
                        active6 = True
                        active7 = False
                        active8 = False
                    if input_rect7.collidepoint(event.pos):
                        active1 = False
                        active2 = False
                        active3 = False
                        active4 = False
                        active5 = False
                        active6 = False
                        active7 = True
                        active8 = False
                    if input_rect8.collidepoint(event.pos):
                        active1 = False
                        active2 = False
                        active3 = False
                        active4 = False
                        active5 = False
                        active6 = False
                        active7 = False
                        active8 = True
                    if back_button.collidepoint(event.pos):
                        run = False
                        break
                    if run_rect.collidepoint(event.pos):
                        self.runD2(theta11,theta21,phi11,phi21,theta12,theta22,phi12,phi22)
                    if back_rect.collidepoint(event.pos):
                        run = False
                        break
                    if reset_rect.collidepoint(event.pos):
                        theta11 = self.thetao1
                        theta21 = self.thetao2
                        phi11 = self.phio1
                        phi21 = self.phio2
                        theta12 = self.thetao1
                        theta22 = self.thetao2
                        phi12 = self.phio1
                        phi22 = self.phio2
                        
                        user_text1 = str(theta11)
                        user_text2 = str(theta21)
                        user_text3 = str(phi11)
                        user_text4 = str(phi21)
                        user_text5 = str(theta12)
                        user_text6 = str(theta22)
                        user_text7 = str(phi12)
                        user_text8 = str(phi22)
                        
            clock.tick(120)
            self.window.fill(self.bg)
            self.size =self.window.get_size()
            back_button = self.back_button(self.size)
            heading_rect = self.button_with_shadow("Simple pendulum",self.size[0]//2,100,self.special,self.fg,self.common,self.ff2)
            back_rect = self.button_with_shadow("back",self.size[0]//2-200,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
            reset_rect = self.button_with_shadow("reset",self.size[0]//2,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
            run_rect = self.button_with_shadow("run",self.size[0]//2+200,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
            # self.text_left("under construction, well don't want to do it, bored ;(",self.size[0]//2-400,self.size[1]//2,self.bg,self.fg,self.ff2)
            back_button = self.back_button(self.size)

            input_rect1 = self.inputbox("initial displacement 1 for first system= ",input_text=str(user_text1),x=100,y=180,maximum=200,activity=active1,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
            input_rect2 = self.inputbox("initial displacement 2 for first system= ",input_text=str(user_text2),x=100,y=230,maximum=200,activity=active2,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
            input_rect3 = self.inputbox("initial angular velocity 1 for first system= ",input_text=str(user_text3),x=100,y=280,maximum=200,activity=active3,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
            input_rect4 = self.inputbox("initial angular velocity 2 for first system= ",input_text=str(user_text4),x=100,y=330,maximum=200,activity=active4,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)

            input_rect5 = self.inputbox("initial displacement 1 for second system= ",input_text=str(user_text5),x=100,y=380,maximum=200,activity=active5,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
            input_rect6 = self.inputbox("initial displacement 2 for second system= ",input_text=str(user_text6),x=100,y=430,maximum=200,activity=active6,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
            input_rect7 = self.inputbox("initial angular velocity 1 for second system= ",input_text=str(user_text7),x=100,y=480,maximum=200,activity=active7,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
            input_rect8 = self.inputbox("initial angular velocity 2 for second system= ",input_text=str(user_text8),x=100,y=530,maximum=200,activity=active8,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)

            pg.display.flip()
            
    def menuS(self):
        run = True
        clock = pg.time.Clock()
        self.size = self.window.get_size()
        
        self.length1 = 500
        self.length2 = 500
        self.lengtho1 = 500
        self.lengtho2 = 500
        back_button = self.back_button(self.size)
        heading_rect = self.button_with_shadow("Simple pendulum",self.size[0]//2,100,self.special,self.fg,self.common,self.ff2)
        back_rect = self.button_with_shadow("back",self.size[0]//2-200,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
        reset_rect = self.button_with_shadow("reset",self.size[0]//2,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
        run_rect = self.button_with_shadow("run",self.size[0]//2+200,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
        one_pen_rect = self.button_with_shadow("one pendulum system",self.size[0]//2-200,self.size[1]-200,self.extra,self.fg,self.common,self.ff,shadow_distance=2)
        two_pen_rect = self.button_with_shadow("two pendulum system",self.size[0]//2+200,self.size[1]-200,self.special,self.fg,self.common,self.ff)

        length1 = self.length1
        mass1 = self.mass1
        dampcoef = self.dampcoef
        gravity = self.gravity
        theta1 = self.theta1
        phi1 = self.phi1
        


        pos1 = length1/10-1
        pos2 = (mass1-20)/20
        pos3 = dampcoef*2
        pos4 = gravity/100

        active1 = False
        active2 = False

        user_text1 = str(theta1)
        user_text2 = str(phi1)


        color_active = self.special
        color_inactive = self.common

        
        input_rect1 = self.inputbox("initial displacement= ",input_text=str(user_text1),x=100,y=330,maximum=200,activity=active1,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
        input_rect2 = self.inputbox("initial angular velocity = ",input_text=str(user_text2),x=100,y=430,maximum=200,activity=active2,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)

            
        
        
        while run:
            for event in pg.event.get():
                if event.type == pg.QUIT:
                    run = False
                    sys.exit()
                
                if event.type==pg.KEYDOWN:
                    if active1:
                        if event.key==pg.K_BACKSPACE:
                            user_text1=user_text1[:-1]
                        else:
                            if event.key==pg.K_RETURN or event.key==pg.K_KP_ENTER:
                                active1=False
                                try:
                                    theta1 = float(user_text1)
                                except:
                                    user_text1 = str(theta1)
                            else:
                                user_text1+=event.unicode
                    elif active2:
                        if event.key==pg.K_BACKSPACE:
                            user_text2=user_text2[:-1]
                        else:
                            if event.key==pg.K_RETURN or event.key==pg.K_KP_ENTER:
                                active2=False
                                try:
                                    phi1 = float(user_text2)
                                except:
                                    user_text2 = str(phi1)
                            else:
                                user_text2+=event.unicode
                    else:
                        user_text = "0.0"
                if event.type==pg.MOUSEBUTTONDOWN:
                    if input_rect1.collidepoint(event.pos):
                        active1 = True
                        active2 = False
                    if input_rect2.collidepoint(event.pos):
                        active1 = False
                        active2 = True
                    if back_button.collidepoint(event.pos):
                        run = False
                        break
                    if run_rect.collidepoint(event.pos):
                        self.length1 = length1
                        self.mass1 = mass1
                        self.dampcoef = dampcoef
                        self.gravity = gravity
                        self.theta1 = theta1
                        self.phi1 = phi1
                        self.run1()
                    if back_rect.collidepoint(event.pos):
                        run = False
                        break
                    if reset_rect.collidepoint(event.pos):
                        pos1 = (self.lengtho1/10)-1
                        pos2 = (self.masso1-20)/20
                        pos3 = self.dampcoefo*2
                        pos4 = self.gravityo/100
                        theta1 = self.thetao1
                        phi1 = self.phio1
                        user_text1 = str(self.thetao1)
                        user_text2 = str(self.phio1)
                    if two_pen_rect.collidepoint(event.pos):
                        self.menu_of_two_pendulum()
                        run = False
                        break
                # all the keys and control. 
            # body

            clock.tick(120)
            self.window.fill(self.bg)
            self.size = self.window.get_size()

            back_button = self.back_button(self.size)
            heading_rect = self.button_with_shadow("Simple pendulum",self.size[0]//2,100,self.special,self.fg,self.common,self.ff2)
            back_rect = self.button_with_shadow("back",self.size[0]//2-200,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
            reset_rect = self.button_with_shadow("reset",self.size[0]//2,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
            run_rect = self.button_with_shadow("run",self.size[0]//2+200,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
            one_pen_rect = self.button_with_shadow("one pendulum system",self.size[0]//2-200,self.size[1]-200,self.extra,self.fg,self.common,self.ff,shadow_distance=3)
            two_pen_rect = self.button_with_shadow("two pendulum system",self.size[0]//2+200,self.size[1]-200,self.special,self.fg,self.common,self.ff)

            
            # rectangle drawing
            
            self.text_left("length =   "+str(round(length1)),90,170,self.bg,self.fg,self.ff)
            pos1 = self.slider(self.size[0]//2-250,170+20,pos1)
            length1 = round((pos1*10)+10)


            self.text_left("mass =   "+str(round(mass1)),self.size[0]//2,170,self.bg,self.fg,self.ff)
            pos2 = self.slider(self.size[0]-250,170+20,pos2)
            mass1 = round(pos2*20+20)

            self.text_left("damp coeffciant=   "+str(dampcoef),90,220,self.bg,self.fg,self.ff)
            pos3 = self.slider(self.size[0]//2-250,220+20,pos3)
            dampcoef = round(pos3/200,6)

            self.text_left("gravity=   "+str(round(gravity)),self.size[0]//2,220,self.bg,self.fg,self.ff)
            pos4 = self.slider(self.size[0]-250,220+20,pos4)
            gravity = round(10*pos4)+882

            input_rect1 = self.inputbox("initial displacement= ",input_text=str(user_text1),x=100,y=330,maximum=200,activity=active1,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
            input_rect2 = self.inputbox("initial angular velocity= ",input_text=str(user_text2),x=100,y=380,maximum=200,activity=active2,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)

            

            pg.display.flip()


    def menu_of_two_pendulum(self):
        run = True
        clock = pg.time.Clock()
        self.size = self.window.get_size()
        
        back_button = self.back_button(self.size)
        heading_rect = self.button_with_shadow("Simple pendulum",self.size[0]//2,100,self.special,self.fg,self.common,self.ff2)
        back_rect = self.button_with_shadow("back",self.size[0]//2-200,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
        reset_rect = self.button_with_shadow("reset",self.size[0]//2,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
        run_rect = self.button_with_shadow("run",self.size[0]//2+200,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
        exact_rect = self.button_with_shadow("exact solution",self.size[0]//2-200,self.size[1]-200,self.special,self.fg,self.common,self.ff)
        appro_rect = self.button_with_shadow("appoximated solution",self.size[0]//2+200,self.size[1]-200,self.special,self.fg,self.common,self.ff)

        length1 = self.length1
        length2 = self.length2
        mass1 = self.mass1
        mass2 = self.mass2
        dampcoef1 = self.dampcoef
        dampcoef2 = self.dampcoef
        gravity1 = self.gravity
        gravity2 = self.gravity
        theta1 = self.theta1
        theta2 = self.theta2
        phi1 = self.phi1
        phi2 = self.phi2

        
        pos1 = length1/10-1
        pos2 = length2/10-1
        pos3 = (mass1-20)/20
        pos4 = (mass2-20)/20
        pos5 = dampcoef1*2
        pos6 = dampcoef2*2
        pos7 = gravity1/100
        pos8 = gravity2/100


        active1 = False
        active2 = False
        active3 = False
        active4 = False

        user_text1 = str(theta1)
        user_text2 = str(theta2)
        user_text3 = str(phi1)
        user_text4 = str(phi2)


        color_active = self.special
        color_inactive = self.common

        
        input_rect1 = self.inputbox("initial displacement 1= ",input_text=str(user_text1),x=100,y=330,maximum=200,activity=active1,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
        input_rect2 = self.inputbox("initial displacement 2 = ",input_text=str(user_text2),x=100,y=380,maximum=200,activity=active2,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
        input_rect3 = self.inputbox("initial angular velocity 1 = ",input_text=str(user_text3),x=100,y=430,maximum=200,activity=active3,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
        input_rect4 = self.inputbox("initial angular velocity 2 = ",input_text=str(user_text4),x=100,y=480,maximum=200,activity=active4,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)

    
        appro = True
        while run:
            for event in pg.event.get():
                if event.type==pg.QUIT:
                    run = False
                    sys.exit()

                if event.type==pg.KEYDOWN:
                    if active1:
                        if event.key==pg.K_BACKSPACE:
                            user_text1=user_text1[:-1]
                        else:
                            if event.key==pg.K_RETURN or event.key==pg.K_KP_ENTER:
                                active1=False
                                try:
                                    theta1 = float(user_text1)
                                except:
                                    user_text1 = str(theta1)
                            else:
                                user_text1+=event.unicode
                    elif active2:
                        if event.key==pg.K_BACKSPACE:
                            user_text2=user_text2[:-1]
                        else:
                            if event.key==pg.K_RETURN or event.key==pg.K_KP_ENTER:
                                active2=False
                                try:
                                    theta2 = float(user_text2)
                                except:
                                    user_text2 = str(theta2)
                            else:
                                user_text2+=event.unicode

                    elif active3:
                        if event.key==pg.K_BACKSPACE:
                            user_text3=user_text3[:-1]
                        else:
                            if event.key==pg.K_RETURN or event.key==pg.K_KP_ENTER:
                                active3=False
                                try:
                                    phi1 = float(user_text3)
                                except:
                                    user_text3 = str(phi1)
                            else:
                                user_text3+=event.unicode

                    elif active4:
                        if event.key==pg.K_BACKSPACE:
                            user_text4=user_text4[:-1]
                        else:
                            if event.key==pg.K_RETURN or event.key==pg.K_KP_ENTER:
                                active4=False
                                try:
                                    phi2 = float(user_text4)
                                except:
                                    user_text4 = str(phi2)
                            else:
                                user_text4+=event.unicode

                    else:
                        user_text = "0.0"
                if event.type==pg.MOUSEBUTTONDOWN:
                    if input_rect1.collidepoint(event.pos):
                        active1 = True
                        active2 = False
                        active3 = False
                        active4 = False
                    if input_rect2.collidepoint(event.pos):
                        active1 = False
                        active2 = True
                        active3 = False
                        active4 = False
                    if input_rect3.collidepoint(event.pos):
                        active1 = False
                        active2 = False
                        active3 = True
                        active4 = False
                    if input_rect4.collidepoint(event.pos):
                        active1 = False
                        active2 = False
                        active3 = False
                        active4 = True
                    if back_button.collidepoint(event.pos):
                        run = False
                        break
                    if run_rect.collidepoint(event.pos):
                        self.length1 = length1
                        self.length2 = length2
                        self.mass1 = mass1
                        self.mass2 = mass2
                        self.theta1 = theta1
                        self.theta2 = theta2
                        self.phi1 = phi1
                        self.phi2 = phi2
                        if appro:
                            self.run22(dampcoef1,dampcoef2,gravity1,gravity2)
                        else:
                            self.run21(dampcoef1,dampcoef2,gravity1,gravity2)
                    if exact_rect.collidepoint(event.pos):
                        appro=False
                    if appro_rect.collidepoint(event.pos):
                        appro=True
                    if back_rect.collidepoint(event.pos):
                        run = False
                        break
                    if reset_rect.collidepoint(event.pos):
                        pos1 = (self.lengtho1/10)-1
                        pos2 = (self.lengtho2/10)-1
                        pos3 = (self.masso1-20)/20
                        pos4 = (self.masso2-20)/20
                        pos5 = self.dampcoefo*2
                        pos6 = self.dampcoefo*2
                        pos7 = self.gravityo/100
                        pos8 = self.gravityo/100
                        
                        theta1 = self.thetao1
                        theta2 = self.thetao2
                        phi1 = self.phio1
                        phi2 = self.phio2
                        user_text1 = str(theta1)
                        user_text2 = str(theta2)
                        user_text3 = str(phi1)
                        user_text4 = str(phi2)
            clock.tick(60)
            self.window.fill(self.bg)
            self.size = self.window.get_size()

            back_button = self.back_button(self.size)
            heading_rect = self.button_with_shadow("Simple pendulum",self.size[0]//2,100,self.special,self.fg,self.common,self.ff2)
            back_rect = self.button_with_shadow("back",self.size[0]//2-200,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
            reset_rect = self.button_with_shadow("reset",self.size[0]//2,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
            run_rect = self.button_with_shadow("run",self.size[0]//2+200,self.size[1]-100,self.special,self.fg,self.common,self.ff2)
            if appro:
                exact_rect = self.button_with_shadow("exact solution",self.size[0]//2-200,self.size[1]-180,self.special,self.fg,self.common,self.ff)
                appro_rect = self.button_with_shadow("appoximated solution",self.size[0]//2+200+3,self.size[1]-180+3,self.extra,self.fg,self.common,self.ff,shadow_distance = 3)
            else:
                exact_rect = self.button_with_shadow("exact solution",self.size[0]//2-200+3,self.size[1]-180+3,self.extra,self.fg,self.common,self.ff,shadow_distance=3)
                appro_rect = self.button_with_shadow("appoximated solution",self.size[0]//2+200,self.size[1]-180,self.special,self.fg,self.common,self.ff)
            
            # rectangle drawing
            
            self.text_left("length 1=   "+str(round(length1)),90,170,self.bg,self.fg,self.ff)
            pos1 = self.slider(self.size[0]//2-250,170+20,pos1)
            length1 = round((pos1*10)+10)


            pos2 = self.slider(self.size[0]-250,170+20,pos2)
            length2 = round((pos2*10)+10)
            self.text_left("length 2=   "+str(round(length2)),self.size[0]//2,170,self.bg,self.fg,self.ff)

            pos3 = self.slider(self.size[0]//2-250,220+20,pos3)
            mass1 = round(pos3*20+20)
            self.text_left("mass 1=   "+str(round(mass1)),90,220,self.bg,self.fg,self.ff)

            pos4 = self.slider(self.size[0]-250,220+20,pos4)
            mass2 = round(pos4*20+20)
            self.text_left("mass 2=   "+str(round(mass2)),self.size[0]//2,220,self.bg,self.fg,self.ff)

            pos5 = self.slider(self.size[0]//2-250,270+20,pos5)
            dampcoef1 = round(pos5/200,3)
            self.text_left("damp coeffciant (1)=   "+str(dampcoef1),90,270,self.bg,self.fg,self.ff)

            pos6 = self.slider(self.size[0]-250,270+20,pos6)
            dampcoef2 = round(pos6/200,3)
            self.text_left("damp coeffciant (2)=   "+str(dampcoef2),self.size[0]//2,270,self.bg,self.fg,self.ff)
    
            pos7 = self.slider(self.size[0]//2-250,320+20,pos7)
            gravity1 = round(10*pos7)+882
            self.text_left("gravity (1)=   "+str(round(gravity1)),90,320,self.bg,self.fg,self.ff)

            pos8 = self.slider(self.size[0]-250,320+20,pos8)
            gravity2 = round(10*pos8)+882
            self.text_left("gravity (2)=   "+str(round(gravity2)),self.size[0]//2,320,self.bg,self.fg,self.ff)

            
            input_rect1 = self.inputbox("initial displacement 1= ",input_text=str(user_text1),x=100,y=400,maximum=200,activity=active1,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
            input_rect2 = self.inputbox("initial displacement 2 = ",input_text=str(user_text2),x=self.size[0]//2,y=400,maximum=200,activity=active2,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
            input_rect3 = self.inputbox("initial angular velocity 1 = ",input_text=str(user_text3),x=100,y=450,maximum=200,activity=active3,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)
            input_rect4 = self.inputbox("initial angular velocity 2 = ",input_text=str(user_text4),x=self.size[0]//2,y=450,maximum=200,activity=active4,background=self.bg,foreground=self.fg,active_color=color_active,inactive_color=color_inactive,font=self.ff)

            
            pg.display.flip()

        

    def run1(self):
        run = True
        
        clock = pg.time.Clock()
        pen = Pendulum(self.length1,self.mass1,self.dampcoef,self.gravity,self.theta1,self.phi1,image="bitmap1.png")
        E0 = pen.initial_E()
        T,V,E = pen.energy()
        E0 = max(E,E0)
        # T = 2*pi*sqrt(self.length1/self.gravity)
        menu_button = self.button_with_shadow("menu",100,100,self.special,self.fg,self.common,self.ff2)
        TP,W = pen.timeperiod()
        while run:
            for event in pg.event.get():
                if event.type == pg.QUIT:
                    run = False
                    break
                if event.type == pg.KEYDOWN:
                    if event.key==pg.K_ESCAPE:
                        run = False
                        break
                if event.type==pg.MOUSEBUTTONDOWN:
                    if menu_button.collidepoint(event.pos):
                        run = False
                        break
            # main loop 
            clock.tick(120)
            self.window.fill(self.bg)
            origin = (self.window.get_size()[0]//2,100)
            
            T,V,E = pen.energy()
            menu_button = self.button_with_shadow("menu",100,100,self.special,self.fg,self.common,self.ff2)
            self.text_left("length= "+str(self.length1)+" cm",50,300,self.bg,self.fg,self.ff)
            self.text_left("mass= "+str(self.mass1)+" gm",50,350,self.bg,self.fg,self.ff)
            self.text_left("time period= "+str(round(TP,4))+" s",50,400,self.bg,self.fg,self.ff)
            self.text_left("angular frequency= "+str(round(W,4))+" rad/s",50,450,self.bg,self.fg,self.ff)
            self.text_left("E= ",50,500,self.bg,self.fg,self.ff)
            self.bar(300,515,E0,E)
            self.text_left("T= ",50,550,self.bg,self.fg,self.ff)
            self.bar(300,565,E0,T)
            self.text_left("V= ",50,600,self.bg,self.fg,self.ff)
            self.bar(300,615,E0,V)
            
            pen.draw(self.window,origin)
            pen.update()

            pg.display.flip()

    



    def run21(self,dampcoef1,dampcoef2,gravity1,gravity2):
        run = True
        clock = pg.time.Clock()
        pen1 = Pendulum(self.length1,self.mass1,dampcoef1,gravity1,self.theta1,self.phi1,image="bitmap1.png")
        pen2 = Pendulum(self.length2,self.mass2,dampcoef2,gravity2,self.theta2,self.phi2,image="bitmap2.png")
        T1,V1,E1 = pen1.energy()
        T2,V2,E2 = pen2.energy()
        E01 = pen1.initial_E()
        E02 = pen2.initial_E()
        E01 = max(E1,E01)
        E02 = max(E2,E02)
        image1 = load_image("bitmap1.png")
        image2 = load_image("bitmap2.png")
        # T = 2*pi*sqrt(self.length1/self.gravity)
        menu_button = self.button_with_shadow("menu",100,100,self.special,self.fg,self.common,self.ff2)
        TP1,W1 = pen1.timeperiod()
        TP2,W2 = pen2.timeperiod()
        while run:
            for event in pg.event.get():
                if event.type == pg.QUIT:
                    run = False
                    break
                if event.type == pg.KEYDOWN:
                    if event.key==pg.K_ESCAPE:
                        run = False
                        break
                if event.type==pg.MOUSEBUTTONDOWN:
                    if menu_button.collidepoint(event.pos):
                        run = False
                        break
            # main loop 
            clock.tick(120)
            self.window.fill(self.bg)
            origin = (self.window.get_size()[0]//2,100)
            
            T1,V1,E1 = pen1.energy()
            T2,V2,E2 = pen2.energy()
            menu_button = self.button_with_shadow("menu",100,100,self.special,self.fg,self.common,self.ff2)
            self.text_left("length= "+str(self.length1)+" cm",50,300,self.bg,self.fg,self.ff)
            self.text_left("mass= "+str(self.mass1)+" gm",50,350,self.bg,self.fg,self.ff)
            self.text_left("time period= "+str(round(TP1,4))+" s",50,400,self.bg,self.fg,self.ff)
            self.text_left("angular frequency= "+str(round(W1,4))+" rad/s",50,450,self.bg,self.fg,self.ff)

            self.window.blit(image1,(self.size[0]-345,212))
            self.window.blit(image2,(self.size[0]-345,262))
            self.text_left("pendulum 1",self.size[0]-325,200,self.bg,self.fg,self.ff)
            self.text_left("pendulum 2",self.size[0]-325,250,self.bg,self.fg,self.ff)
            self.text_left("E= ",50,500,self.bg,self.fg,self.ff)
            self.bar(100,515,E01,E1)
            self.text_left("T= ",50,550,self.bg,self.fg,self.ff)
            self.bar(100,565,E01,T1)
            self.text_left("V= ",50,600,self.bg,self.fg,self.ff)
            self.bar(100,615,E01,V1)

            self.text_left("length= "+str(self.length2)+" cm",self.size[0]-350,300,self.bg,self.fg,self.ff)
            self.text_left("mass= "+str(self.mass2)+" gm",self.size[0]-350,350,self.bg,self.fg,self.ff)
            self.text_left("time period= "+str(round(TP2,4))+" s",self.size[0]-350,400,self.bg,self.fg,self.ff)
            self.text_left("angular frequency= "+str(round(W2,4))+" rad/s",self.size[0]-350,450,self.bg,self.fg,self.ff)
            # self.text_left("total enetgy= ",self.size[0]-500,500,self.bg,self.fg,self.ff)
            self.bar(self.size[0]-325,515,E02,E2)
            # self.text_left("kinetic energy= ",self.size[0]-500,550,self.bg,self.fg,self.ff)
            self.bar(self.size[0]-325,565,E02,T2)
            # self.text_left("potential energy= ",self.size[0]-500,600,self.bg,self.fg,self.ff)
            self.bar(self.size[0]-325,615,E02,V2)
            
            pen1.draw(self.window,origin)
            pen2.draw(self.window,origin)
            pen1.update()
            pen2.update()

            pg.display.flip()
        
   
    def run22(self,dampcoef1,dampcoef2,gravity1,gravity2):
        run = True
        clock = pg.time.Clock()
        pen1 = Pendulum(self.length1,self.mass1,dampcoef1,gravity1,self.theta1,self.phi1,image="bitmap1.png")
        pen2 = PendulumAppro(self.length2,self.mass2,dampcoef2,gravity2,self.theta2,self.phi2,image="bitmap2.png")
        T1,V1,E1 = pen1.energy()
        T2,V2,E2 = pen2.energy()
        E01 = pen1.initial_E()
        E02 = pen2.initial_E()
        E01 = max(E1,E01)
        E02 = max(E2,E02)
        menu_button = self.button_with_shadow("menu",100,100,self.special,self.fg,self.common,self.ff2)
        TP1,W1 = pen1.timeperiod()
        TP2,W2 = pen2.timeperiod()
        image1 = load_image("bitmap1.png")
        image2 = load_image("bitmap2.png")
        while run:
            for event in pg.event.get():
                if event.type == pg.QUIT:
                    run = False
                    break
                if event.type == pg.KEYDOWN:
                    if event.key==pg.K_ESCAPE:
                        run = False
                        break
                if event.type==pg.MOUSEBUTTONDOWN:
                    if menu_button.collidepoint(event.pos):
                        run = False
                        break
            # main loop 
            clock.tick(120)
            self.window.fill(self.bg)
            origin = (self.window.get_size()[0]//2,100)
            
            T1,V1,E1 = pen1.energy()
            T2,V2,E2 = pen2.energy()
            menu_button = self.button_with_shadow("menu",100,100,self.special,self.fg,self.common,self.ff2)
            self.text_left("length= "+str(self.length1)+" cm",50,500,self.bg,self.fg,self.ff)
            self.text_left("mass= "+str(self.mass1)+" gm",50,550,self.bg,self.fg,self.ff)
            self.text_left("time period= "+str(round(TP1,4))+" s",50,600,self.bg,self.fg,self.ff)
            self.text_left("angular frequency= "+str(round(W1,4))+" rad/s",50,650,self.bg,self.fg,self.ff)

            self.window.blit(image1,(self.size[0]-345,212))
            self.window.blit(image2,(self.size[0]-345,262))
            self.text_left("exact solution",self.size[0]-325,200,self.bg,self.fg,self.ff)
            self.text_left("approximated solution",self.size[0]-325,250,self.bg,self.fg,self.ff)
            # self.text_left("E= ",50,500,self.bg,self.fg,self.ff)
            # self.bar(100,515,E01,E1)
            # self.text_left("T= ",50,550,self.bg,self.fg,self.ff)
            # self.bar(100,565,E01,T1)
            # self.text_left("V= ",50,600,self.bg,self.fg,self.ff)
            # self.bar(100,615,E01,V1)

            self.text_left("length= "+str(self.length2)+" cm",self.size[0]-350,500,self.bg,self.fg,self.ff)
            self.text_left("mass= "+str(self.mass2)+" gm",self.size[0]-350,550,self.bg,self.fg,self.ff)
            self.text_left("time period= "+str(round(TP2,4))+" s",self.size[0]-350,600,self.bg,self.fg,self.ff)
            self.text_left("angular frequency= "+str(round(W2,4))+" rad/s",self.size[0]-350,650,self.bg,self.fg,self.ff)
            # self.text_left("total enetgy= ",self.size[0]-500,500,self.bg,self.fg,self.ff)
            # self.bar(self.size[0]-315,515,E02,E2)
            # self.text_left("kinetic energy= ",self.size[0]-500,550,self.bg,self.fg,self.ff)
            # self.bar(self.size[0]-315,565,E02,T2)
            # self.text_left("potential energy= ",self.size[0]-500,600,self.bg,self.fg,self.ff)
            # self.bar(self.size[0]-315,615,E02,V2)
            
            pen1.draw(self.window,origin)
            pen2.draw(self.window,origin)
            pen1.update()
            pen2.update()

            pg.display.flip()
        

    def runD1(self):
        run = True
        clock = pg.time.Clock()
        pen = DoublePendulum(self.mass1,self.mass2,self.length1,self.length2,self.dampcoef,self.gravity,self.theta1,self.theta2,self.phi1,self.phi2)
        
        menu_button = self.button_with_shadow("menu",100,100,self.special,self.fg,self.common,self.ff2)
        T,V,E = pen.energy()
        E0 = pen.initial_energy()
        E0 = max(E,E0)
        while run:
            for event in pg.event.get():
                if event.type == pg.QUIT:
                    run = False
                    break
                if event.type == pg.KEYDOWN:
                    if event.key==pg.K_ESCAPE:
                        run = False
                        break
                if event.type==pg.MOUSEBUTTONDOWN:
                    if menu_button.collidepoint(event.pos):
                        run = False
                        break
            # main loop 
            clock.tick(120)
            self.window.fill(self.bg)
            origin = (self.window.get_size()[0]//2,100)
            
            menu_button = self.button_with_shadow("menu",100,100,self.special,self.fg,self.common,self.ff2)
            T,V,E = pen.energy()
            self.text_left("length1= "+str(self.length1)+" cm",50,400,self.bg,self.fg,self.ff)
            self.text_left("length2= "+str(self.length2)+" cm",50,450,self.bg,self.fg,self.ff)
            self.text_left("mass1= "+str(self.mass1)+" gm",50,500,self.bg,self.fg,self.ff)
            self.text_left("mass2= "+str(self.mass2)+" gm",50,550,self.bg,self.fg,self.ff)
            self.text_left("E",self.size[0]-50,500,self.bg,self.fg,self.ff)
            self.bar(self.size[0]-400,515,E0,E)
            self.text_left("T ",self.size[0]-50,550,self.bg,self.fg,self.ff)
            self.bar(self.size[0]-400,565,E0,T)
            self.text_left("V ",self.size[0]-50,600,self.bg,self.fg,self.ff)
            self.bar(self.size[0]-400,615,E0,V)
            pen.draw(self.window)
            pen.update()

            pg.display.flip()

    def runD2(self,theta11,theta21,phi11,phi21,theta12,theta22,phi12,phi22):
        run = True
        clock = pg.time.Clock()
        pen1 = DoublePendulum(self.mass1,self.mass2,self.length1,self.length2,self.dampcoef,self.gravity,theta11,theta21,phi11,phi21)
        pen2 = DoublePendulum(self.mass1,self.mass2,self.length1,self.length2,self.dampcoef,self.gravity,theta12,theta22,phi12,phi22,image="bitmap2.png") 
        menu_button = self.button_with_shadow("menu",100,100,self.special,self.fg,self.common,self.ff2)
        # T,V,E = pen1.energy()
        # E0 = pen.initial_energy()
        while run:
            for event in pg.event.get():
                if event.type == pg.QUIT:
                    run = False
                    break
                if event.type == pg.KEYDOWN:
                    if event.key==pg.K_ESCAPE:
                        run = False
                        break
                if event.type==pg.MOUSEBUTTONDOWN:
                    if menu_button.collidepoint(event.pos):
                        run = False
                        break
            # main loop 
            clock.tick(60)
            self.window.fill(self.bg)
            origin = (self.window.get_size()[0]//2,100)
            menu_button = self.button_with_shadow("menu",100,100,self.special,self.fg,self.common,self.ff2)
            # T,V,E = pen.energy()
            self.text_left("length1= "+str(self.length1)+" cm",50,400,self.bg,self.fg,self.ff)
            self.text_left("length2= "+str(self.length2)+" cm",50,450,self.bg,self.fg,self.ff)
            self.text_left("mass1= "+str(self.mass1)+" gm",50,500,self.bg,self.fg,self.ff)
            self.text_left("mass2= "+str(self.mass2)+" gm",50,550,self.bg,self.fg,self.ff)
            # self.text_left("E= ",50,500,self.bg,self.fg,self.ff)
            # self.bar(100,515,E0,E)
            # self.text_left("T= ",50,550,self.bg,self.fg,self.ff)
            # self.bar(100,565,E0,T)
            # self.text_left("V= ",50,600,self.bg,self.fg,self.ff)
            # self.bar(100,615,E0,V)
            pen1.draw(self.window)
            pen2.draw(self.window)
            pen1.update()
            pen2.update()

            pg.display.flip()
    

            
            
                
k = Simulation()
k.mainmenu()

#+end_src

Simulation files are /lindamsamepos.py/, /nonlindamsamepos.py/ and also
two other /lindamdiffpos.py/ and /nonlindamdiffpos.py/. In the files
respecevely i put my code for linear damping with same pivot position
and also quadratic damping with same position of pivot. Other two files
are complementary for different pivot position not much of importance.
Thanks to pygame library this was possible.

I am writing here my linear damping file for regeneration perpose in
other two i just changed fuction name from /main.py/. I used numpy for
my mathematics calculations.[cite:@harris2020array]

#+begin_src python
  from main import *
  import pygame
  import time
  from numpy import cos, sin, pi


  # this part done.
  # just do - [ ] dual color balls



  def bob1(window,x,y):
      image = pygame.image.load("bitmap1.png")
      window.blit(image, (x,y))

  def bob2(window,x,y):
      image = pygame.image.load("bitmap2.png")
      window.blit(image, (x,y))

  def surface(window,x,y):
     image = pygame.image.load("surface.png")
     window.blit(image, (x, y))



  def position(l,theta):
     return origin_x-10+l*cos((1.5*pi)-theta),origin_y-10-l*sin((1.5*pi)-theta)

  def mainloop(window,fps):
      global t
      run = True
      clock = pygame.time.Clock()
      c = 0
      while run:
          for event in pygame.event.get():
              if event.type== pygame.QUIT:
                  run= False
                  break
          clock.tick(fps)

          x,y = position(l,exact[c])
          x2,y2 = position(l,appro[c])
          if c==len(exact):
              break
          window.fill("#ffffff")
          surface(window,200,origin_y-15)
          pygame.draw.aaline(window,color="#5BDEC1",start_pos=(origin_x,origin_y),end_pos=(x+radius,y+radius))
          pygame.draw.aaline(window,color="#5BDEC1",start_pos=(origin_x,origin_y),end_pos=(x2+10,y2+10))
          bob1(window,x,y)
          bob2(window,x2,y2)
          pygame.display.update()
          c+=1
          pygame.quit()

  if __name__ == "__main__":
      pygame.init()
      window = pygame.display.set_mode((width,height))
      exact = nonlinear_linear(theta_initial,300,fps)
      appro = linear_linear(theta_initial,300,fps)
      t = time.perf_counter()
      mainloop(window, fps)

#+end_src

** Code for graphs
   :PROPERTIES:
   :CUSTOM_ID: sec:orgb9da19f
   :END:
This is code for all the graphs in this document. I have written two
functions which gives one plot for angular frequancy and other gives
\(\theta\) vs time \(t\) for different \(\theta_{0}\). I used matplotlib
for as graphical library [cite:@Hunter2007].

#+begin_src python
from main import *
import numpy as np
import matplotlib.pyplot as plt




def angfre():
    A = np.linspace(-np.pi,np.pi,6000)
    w = np.zeros(np.size(A))
    w0 = np.zeros(np.size(A))

    for i in range(np.size(A)):
        w[i] = w_nonliner(A[i])
        w0[i] = np.sqrt(g/l)

    
    plt.figure()
    plt.plot(A,w, label="angular frequency of nonlinear solution")
    plt.plot(A,w0, label="angular frequency of linear solution")
    plt.title("angular frequency")
    plt.ylabel("angular frequency")
    plt.xlabel("initial displacement")
    plt.legend()
    plt.savefig("angfre.png")
    plt.close
    
def thetawitht(total_time):
    fig = plt.figure()
    # fig, ((ax1,ax2),(ax3,ax4)) = plt.subplots(2, 2, sharex=True, sharey=True)
    gs = fig.add_gridspec(2, 2)
    (ax1, ax2), (ax3, ax4) = gs.subplots()

    fig.suptitle('Angular displacement vs time t')
    # plt.xlabel("time")
    # plt.ylabel("angular displacement")

    time  = np.linspace(0,total_time,1002)



    theta_initial = pi/10
    soll = linear_linear(theta_initial,total_time,int(1000/total_time))
    soln = nonlinear_linear(theta_initial,total_time,int(1000/total_time))
    ax1.plot(time,soll)
    ax1.plot(time,soln)
    ax1.set_title("theta = pi/10")
    # plt.ylabel("angular displacement")


    theta_initial = theta_initial*2
    soll = linear_linear(theta_initial,total_time,int(1000/total_time))
    soln = nonlinear_linear(theta_initial,total_time,int(1000/total_time))
    ax2.plot(time,soll)
    ax2.plot(time,soln)
    ax2.set_title("theta = pi/5")

    theta_initial = pi/2
    soll = linear_linear(theta_initial,total_time,int(1000/total_time))
    soln = nonlinear_linear(theta_initial,total_time,int(1000/total_time))
    ax3.plot(time,soll)
    ax3.plot(time,soln)
    ax3.set_title("theta = pi/2")

    theta_initial = pi
    soll = linear_linear(theta_initial,total_time,int(1000/total_time))
    soln = nonlinear_linear(theta_initial,total_time,int(1000/total_time))
    ax4.plot(time,soll)
    ax4.plot(time,soln)
    ax4.set_title("theta = pi")
    fig.tight_layout()
    plt.savefig("thetawitht.png")
    plt.close()


angfre()
thetawitht(40)

#+end_src

And this is the code that i written for plotting phase planes,

#+begin_src python
from numpy import linspace, meshgrid
from main import *
import matplotlib.pyplot as plt


def exact_lineardamp():
    x1 = linspace(-6,6,2000)
    x2 = linspace(-6,6,2000)

    x1_,x2_ = meshgrid(x1,x2)

    u,v = nonlinear_phase_plane(x1_,x2_)
    vel = sqrt(u**2+v**2)

    plt.figure()
    plt.streamplot(x1_,x2_,u,v, color='k', linewidth=0.8,density=1.5, minlength=0.01, arrowsize=0.8,arrowstyle="->")
    plt.title("stream plot of equation without approximation")
    plt.xlabel("$\theta$")
    plt.ylabel("$\phi$")
    plt.savefig("exactlstr.png")

def appro_lineardamp():
    x1 = linspace(-6,6,2000)
    x2 = linspace(-6,6,2000)

    x1_,x2_ = meshgrid(x1,x2)

    u,v = linear_phase_plane(x1_,x2_)
    vel = sqrt(u**2+v**2)

    plt.figure()
    plt.streamplot(x1_,x2_,u,v, color='k', linewidth=0.8,density=1.5, minlength=0.01, arrowsize=0.8,arrowstyle="->")
    plt.title("stream plot of approximated equation")
    plt.xlabel("$\theta$")
    plt.ylabel("$\phi$")
    plt.savefig("approlstr.png")

exact_lineardamp()
appro_lineardamp()
#+end_src

** References
[1] Richard Bronson and Gabriel B Costa. . McGraw-Hill Education, 2014.

[2] Herbert Goldstein, Charles Poole, and John Safko. Classical
mechanics, 2002.

[3] Walter RA Goossens. Review of the empirical correlations for the drag
coefficient of rigid spheres. , 352:350--359, 2019.

[4] Charles R Harris, K Jarrod Millman, Stéfan J Van Der Walt, Ralf Gommers,
Pauli Virtanen, David Cournapeau, Eric Wieser, Julian Taylor, Sebastian
Berg, Nathaniel J Smith, et al. Array programming with numpy. ,
585(7825):357--362, 2020.

[5] J. D. Hunter. Matplotlib: A 2d graphics environment. ,
9(3):90--95, 2007.

[6] Kim Johannessen. An analytical solution to the equation of motion for
the damped nonlinear pendulum. , 35(3):035014, 2014.

[7] Dominic Jordan and Peter Smith. . OUP Oxford, 2007.

[8] Marko V Lubarda and Vlado A Lubarda. An analysis of pendulum motion in
the presence of quadratic and linear drag. , 42(055014):055014, 2021.

[9] VD Majumdar and MB Vajifdar. Coefficient of viscosity of air. In
/Proceedings of the Indian Academy of Sciences-Section A/, volume 8,
pages 171--178. Springer, 1938.

[10] Robert Salamon, Henryk Kamiński, and Paweł Fritzkowski. Estimation of
parameters of various damping models in planar motion of a pendulum. ,
55(9):1655--1677, 2020.

[11] MG Sobamowo. Exact analytical solutions of nonlinear differential
equation of a large amplitude simple pendulum. , 144:70--88, 2020.

[12] JC UPADHYAY. Himalaya Publishing House, 2016.

[13] [[https://github.com/pygame/pygame]]
